<html><head><title>MRS::Client</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >

<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
BODY {
  background: white;
  color: black;
  font-family: arial,sans-serif;
  margin: 0;
  padding: 1ex;
}

A:link, A:visited {
  background: transparent;
  color: #006699;
}

A[href="#POD_ERRORS"] {
  background: transparent;
  color: #FF0000;
}

DIV {
  border-width: 0;
}

DT {
  margin-top: 1em;
  margin-left: 1em;
}

.pod { margin-right: 20ex; }

.pod PRE     {
  background: #eeeeee;
  border: 1px solid #888888;
  color: black;
  padding: 1em;
  white-space: pre;
}

.pod H1      {
  background: transparent;
  color: #006699;
  font-size: large;
}

.pod H1 A { text-decoration: none; }
.pod H2 A { text-decoration: none; }
.pod H3 A { text-decoration: none; }
.pod H4 A { text-decoration: none; }

.pod H2      {
  background: transparent;
  color: #006699;
  font-size: medium;
}

.pod H3      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-style: italic;
}

.pod H4      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-weight: normal;
}

.pod IMG     {
  vertical-align: top;
}

.pod .toc A  {
  text-decoration: none;
}

.pod .toc LI {
  line-height: 1.2em;
  list-style-type: none;
}

  /*]]>*/-->
</style>


</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Sat Jun 22 11:46:45 2013 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#ATTENTION'>ATTENTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient'>MRS::Client</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <li class='indexItem indexItem3'><a href='#setters%2Fgetters'>setters/getters</a>
      <li class='indexItem indexItem3'><a href='#db'>db</a>
      <li class='indexItem indexItem3'><a href='#find'>find</a>
      <li class='indexItem indexItem3'><a href='#blast'>blast</a>
      <li class='indexItem indexItem3'><a href='#clustal'>clustal</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3ADatabank'>MRS::Client::Databank</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <li class='indexItem indexItem3'><a href='#find'>find</a>
      <li class='indexItem indexItem3'><a href='#count'>count</a>
      <li class='indexItem indexItem3'><a href='#entry'>entry</a>
      <li class='indexItem indexItem3'><a href='#id%2C_name%2C_version%2C_blastable%2C_url%2C_script%2C_files%2C_indices%2C_aliases'>id, name, version, blastable, url, script, files, indices, aliases</a>
      <li class='indexItem indexItem3'><a href='#files'>files</a>
      <li class='indexItem indexItem3'><a href='#indices'>indices</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3AFind'>MRS::Client::Find</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#db%2C_terms%2C_query%2C_all_terms_required%2C_max_entries'>db, terms, query, all_terms_required, max_entries</a>
      <li class='indexItem indexItem3'><a href='#count'>count</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3AMultiFind'>MRS::Client::MultiFind</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#db_counts'>db_counts</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3AHit'>MRS::Client::Hit</a>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3ABlast'>MRS::Client::Blast</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#run'>run</a>
      <li class='indexItem indexItem3'><a href='#job'>job</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3ABlast%3A%3AJob'>MRS::Client::Blast::Job</a>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3ABlast%3A%3AResult'>MRS::Client::Blast::Result</a>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3AClustal'>MRS::Client::Clustal</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#run'>run</a>
      <li class='indexItem indexItem3'><a href='#open_cost'>open_cost</a>
      <li class='indexItem indexItem3'><a href='#extend_cost'>extend_cost</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#MRS%3A%3AClient%3A%3AClustal%3A%3AResult'>MRS::Client::Clustal::Result</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#alignment'>alignment</a>
      <li class='indexItem indexItem3'><a href='#diagnostics'>diagnostics</a>
      <li class='indexItem indexItem3'><a href='#failed'>failed</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#MRS_VERSIONS'>MRS VERSIONS</a>
  <ul   class='indexList indexList2'>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new_parameter_mrs_version'>new parameter mrs_version</a>
      <li class='indexItem indexItem3'><a href='#missing_some_result_formats'>missing some result formats</a>
      <li class='indexItem indexItem3'><a href='#search_algorithm_not_supported'>search algorithm not supported</a>
      <li class='indexItem indexItem3'><a href='#no_ClustalW_service'>no ClustalW service</a>
      <li class='indexItem indexItem3'><a href='#aliases'>aliases</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#MISSING_FEATURES%2C_CAVEATS%2C_BUGS'>MISSING FEATURES, CAVEATS, BUGS</a>
  <li class='indexItem indexItem1'><a href='#ADDITIONAL_FILES'>ADDITIONAL FILES</a>
  <li class='indexItem indexItem1'><a href='#DEPENDENCIES'>DEPENDENCIES</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGMENTS'>ACKNOWLEDGMENTS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>MRS::Client - A SOAP-based client of the MRS Retrieval server</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 1.0.1</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    # 1. create a client that does all the work:
    use MRS::Client;

    # ...by default it connects to the MRS service at http://mrs.cmbi.ru.nl/m6
    my $client = MRS::Client-&#62;new();

    # ...or let the client talk to your own MRS servers
    my $client = MRS::Client-&#62;new ( search_url  =&#62; &#39;http://localhost:18081/&#39;,
                                    blast_url   =&#62; &#39;http://localhost:18082/&#39;,;
                                    clustal_url =&#62; &#39;http://localhost:18083/&#39;);  # this only for MRS 5

    # ...or specify only a host, assuming the default ports are used
    my $client = MRS::Client-&#62;new ( host =&#62; &#39;localhost&#39;);

    # 2a. make various queries to a selected database:
    print $client-&#62;db (&#39;uniprot&#39;)-&#62;find (&#39;sapiens&#39;)-&#62;count;
    175642

    print $client-&#62;db (&#39;uniprot&#39;)-&#62;find (&#39;sapiens&#39;)-&#62;next;
    ID   Q14547_HUMAN            Unreviewed;        60 AA.
    AC   Q14547;
    DT   01-NOV-1996, integrated into UniProtKB/TrEMBL.
    DT   01-NOV-1996, sequence version 1.
    DT   19-JAN-2010, entry version 51.
    DE   SubName: Full=Homeobox-like;
    DE   Flags: Fragment;
    OS   Homo sapiens (Human).
    ...

    # show id, relevance score and title of two terms connected by AND
    my $query = $client-&#62;db (&#39;enzyme&#39;)-&#62;find (&#39;and&#39; =&#62; [&#39;snake&#39;, &#39;human&#39;],
                                              &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
    while (my $record = $query-&#62;next) {
       print $record . &#34;\n&#34;;
    }
    enzyme  3.4.21.95   17.6527424   Snake venom factor V activator.

    # ...show only title, but now the same two terms are connected by OR
    my $query = $client-&#62;db (&#39;enzyme&#39;)-&#62;find (&#39;or&#39; =&#62; [&#39;snake&#39;, &#39;human&#39;],
                                              &#39;format&#39; =&#62; MRS::EntryFormat-&#62;TITLE);
    while (my $record = $query-&#62;next) {
       print $record . &#34;\n&#34;;
    }
    Snake venom factor V activator.
    Jararhagin.
    Bothropasin.
    Trimerelysin I.
    ...

    # combine term-based (ranked) query with additional boolean expression
    my $query = $client-&#62;db (&#39;uniprot&#39;)-&#62;find (&#39;and&#39; =&#62; [&#39;snake&#39;, &#39;human&#39;],
                                               query =&#62; &#39;NOT (kinase OR reductase)&#39;,
                                               &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
    print &#34;Count: &#34; . $query-&#62;count . &#34;\n&#34;;
    while (my $record = $query-&#62;next) {
       print $record . &#34;\n&#34;;
    }
    Count: 75
    nxs11_micsu     23.3861961      Short neurotoxin MS11;
    nxl2_micsu      22.7922745      Long neurotoxin MS2;
    nxl5_micsu      22.2648716      Long neurotoxin MS5;
    ...

    # 2b. explore full information about a database
    print $client-&#62;db (&#39;enzyme&#39;);

    # ...or extract only information parts you want
    print $client-&#62;db (&#39;enzyme&#39;)-&#62;version;
    print $client-&#62;db (&#39;enzyme&#39;)-&#62;count;

    # 3. Or, almost all functionality is also available in a provided
    # script I&#60;mrsclient&#62;:

    mrsclient -h
    mrsclient -C
    mrsclient -c -n insulin
    mrsclient -c -p -d enzyme -a &#39;endothelin tyrosine&#39;

    # 4. Run blastp on protein sequences:

    my @run_args = (fasta_file =&#62; &#39;protein.fasta&#39;, db =&#62; &#39;uniprot&#39;);
    my $job = $client-&#62;blast-&#62;run (@run_args);
    print STDERR &#39;JOB ID: &#39; . $job-&#62;id . &#39; [&#39; . $job-&#62;status . &#34;]\n&#34;;
    print $job;
    while (not $job-&#62;completed) {
       print STDERR &#39;Waiting for 10 seconds... [status: &#39; . $job-&#62;status . &#34;]\n&#34;;
       sleep 10;
    }
    print $job-&#62;error if $job-&#62;failed;
    print $job-&#62;results;

    # Or, use for it the provide script I&#60;mrsblast&#62;:

    mrsblast -h
    mrsblast -i /tmp/snake.protein.fasta -d uniprot -x result.xml

    # 5. Run clustalw multiple alignment:
    # (available only for MRS version 5 and lower)

    my $result = $client-&#62;clustal-&#62;run (fasta_file =&#62; &#39;multiple.fasta&#39; );
    print &#34;ERROR: &#34; . $result-&#62;failed if $result-&#62;failed;
    print $result-&#62;diagnostics;
    print $result;

    # Or, use for it the provide script I&#60;mrsclustal&#62;:

    mrsclustal -h
    mrsclustal -i multiple.fasta</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module is a SOAP-based (Web Services) client that can talk, and get data from an <b>MRS server</b>, a search engine for biological and medical databanks that searches well over a terabyte of indexed text. See details about MRS and its author Maarten Hekkelman in <a href="#ACKNOWLEDGMENTS" class="podlinkpod"
>&#34;ACKNOWLEDGMENTS&#34;</a>.</p>

<p>Because this module is only a client, you need an MRS server running. You can install your own (see details in the MRS distribution), or you need to know a site that runs it. By default, this module contacts the MRS server at CMBI (<em>http://mrs.cmbi.ru.nl/m6/</em>).</p>

<p>The usual scenario is the following:</p>

<ul>
<li>Create a new instance of a client by calling:
<pre>    my $client = MRS::Client-&#62;new (%args);</pre>
</li>

<li>Optionally, find out what databanks are available by calling:
<pre>    my @ids = map { $_-&#62;id } $client-&#62;db;
    print &#34;Names:\n&#34; . join (&#34;\n&#34;, @ids) . &#34;\n&#34;;</pre>
</li>

<li>Make one or more queries on a selected databanks and iterate over the result:
<pre>    my $query = $client-&#62;db (&#39;enzyme&#39;)-&#62;find ([&#39;cone&#39;, &#39;snail&#39;]);
    while (my $record = $query-&#62;next) {
       print $record . &#34;\n&#34;;
    }</pre>

<p>Or, make the same query on all available databanks:</p>

<pre>    my $query = $client-&#62;find ([&#39;cone&#39;, &#39;snail&#39;]);
    while (my $record = $query-&#62;next) {
       print $record . &#34;\n&#34;;
    }</pre>

<p>The format of returned records is specified by a parameter of the <i>find</i> method (see more in <a href="#METHODS" class="podlinkpod"
>&#34;METHODS&#34;</a>).</p>
</li>

<li>Additionally, this module provides access to <i>blastp</i> program, using MRS indexed databases. And it can invoke multiple alignment program <i>clustalw</i>.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTENTION"
>ATTENTION</a></h1>

<p><i>For those updating from previous versions of</i> <code>MRS::Client</code>: Because the latest version of MRS server (version 6) is not backward compatible with the previous version of the MRS server (version 5), there are some significant (but fortunately not huge) changes needed in your programs. Read details in <a href="#MRS_VERSIONS" class="podlinkpod"
>&#34;MRS VERSIONS&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client"
>MRS::Client</a></h2>

<p>The main module is <code>MRS::Client</code>. It lets the user specify which MRS server to use, and few other global options. It also has a factory method for creating individual databanks objects. Additionally, it allows making query over all databanks. Finally, it covers all the SOAP communication with the server.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<pre>    use MRS::Client;
    my $client = MRS::Client-&#62;new (@parameters);</pre>

<p>The parameters are name-value pairs. The following names are recognized:</p>

<dl>
<dt><a name="search_url,_blast_url,_clustal_url"
>search_url, blast_url, clustal_url</a></dt>

<dd>
<p>The URLs of the individual MRS servers, one providing searches (the main one), one running blast and one running clustal. Default values lead your searches to CMBI. If you have installed MRS servers on your own site, and you are using the default values coming with the MRS distribution, you create a client by (but see below parameter <i>host</i> for a shortcut):</p>

<pre>    my $client = MRS::Client-&#62;new ( search_url  =&#62; &#39;http://localhost:18081/&#39;,
                                    blast_url   =&#62; &#39;http://localhost:18082/&#39;,
                                    clustal_url =&#62; &#39;http://localhost:18083/&#39;,   # this only for MRS 5
                                   );</pre>

<p>Technical detail: These URLs will be used in the location field of the WSDL description.</p>

<p>Alternatively, you can specify these parameters by environment variables (because they will be probably same for most users from the same site). The parameters, however, still have precedence over the values of environment variables (even if they exist). The variables are: <i>MRS_SEARCH_URL</i>, <i>MRS_BLAST_URL</i> and <i>MRS_CLUSTAL_URL</i>.</p>

<p><b>NOTE:</b> Some sites may not have all MRS servers running.</p>

<dt><a name="host"
>host</a></dt>

<dd>
<p>A shortcut for specifying a host name in all URLs. The same as in the above example can be accomplished by:</p>

<pre>    my $client = MRS::Client-&#62;new (host =&#62; &#39;localhost&#39;);</pre>

<p>Again, you can specify this parameter by an environment variables MRS_HOST.</p>

<dt><a name="search_service,_blast_service,_clustal_service"
>search_service, blast_service, clustal_service</a></dt>

<dd>
<p>The MRS servers are SOAP-based Web Services. Every Web Service has its own <i>service name</i> (the name used in the WSDL). You can change this service name if you are accessing site where they use non-default names. The default names - I guess almost always used - are: mrsws_search, mrsws_blast, mrsws_clustal.</p>

<dt><a name="search_wsdl,_blast_wsdl,_clustal_wsdl"
>search_wsdl, blast_wsdl, clustal_wsdl</a></dt>

<dd>
<p>You can also specify your own WSDL file, each one for each set of operations. It is meant more for debugging purposes because this <code>MRS::Client</code> module understands only current operations and adding new ones to a new WSDL does not magically start using them. These parameters may be useful when extending the <code>MRS::Client</code>.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="setters/getters"
>setters/getters</a></h3>

<p>The same names as the argument names described above can be used as method names to get or set the parameter value. A method without an argument gets the current value, a method with an argument sets the new value. For example:</p>

<pre>   print $client-&#62;search_url;
   $client-&#62;search_url (&#39;http://my.own.server/mrs/search&#39;);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="db"
>db</a></h3>

<p>This is a factory method creating one or more databanks instances. It accepts a single argument, a databank ID:</p>

<pre>   print $client-&#62;db (&#39;enzyme&#39;);

   Id:      enzyme
   Name:    Enzyme
   Version: 2013-05-27
   Count:   6115
   URL:     http://ca.expasy.org/enzyme/
   Parser:  enzyme
   Files:
           Version:       2013-05-27
           Modified:      2013-05-27 11:46 GMT
           Entries count: 6115
           Raw data size: 7436504
           File size:     45563041
           Unique Id:     fc0540bd-58a2-4de7-b3ff-6daff64ca13c
   Indices:
           enzyme         text               14881  Unique
           enzyme         de                  3650  Unique    Description
           enzyme         dr                420832  Unique    Database Reference
           enzyme         id                  6114  Unique    Identification
           enzyme         pr                   398  Unique    Prosite Reference</pre>

<p>You can find out what databanks IDs are available by:</p>

<pre>   print join (&#34;\n&#34;, map { $_-&#62;id } $client-&#62;db);</pre>

<p>Which brings us to the usage of the <i>db</i> method without any parameter, or with an empty parameter. In such cases, it creates an array of <code>MRS::Client::Databank</code> instances.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="find"
>find</a></h3>

<p>Make the same query to all databanks. The parameters are the same as for the <i>find</i> method called for an individual databank (see below).</p>

<pre>   print &#34;Databank\tID\tScore\tTitle\n&#34;;
   my $query = $client-&#62;find (&#39;and&#39; =&#62; [&#39;cone&#39;, &#39;snail&#39;],
                              &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
   while (my
      $record = $query-&#62;next) {
      print $record . &#34;\n&#34;;
   }
   print $query-&#62;count . &#34;\n&#34;;

   Databank  ID           Score       Title
   interpro  ipr020242    29.7122746  Conotoxin I2-superfamily
   interpro  ipr012322    27.8191032  Conotoxin, delta-type, conserved site
   ...
   omim      114020       3.40963793  cadherin 2
   omim      192090       3.40769672  cadherin 1
   sprot     cxd6d_concn  19.4017849  Delta-conotoxin CnVID;
   sprot     cxd6c_concn  19.3984871  Delta-conotoxin CnVIC;
   ...
   taxonomy  6495         53.980381   Conus tulipa fish-hunting cone snail
   trembl    q71ks8_contu 22.1446457  Four-loop conotoxin preproprotein;
   trembl    q9u7q6_contu 20.6787205  Calmodulin;
   ...
   149</pre>

<p>The query (method <i>next</i>) returns entries sequentially, one databank after another. As with individual databanks, even here you can select maximum number of entries to deliver - the number is applied for each databank separately:</p>

<pre>   my $query = $client-&#62;find (&#39;and&#39; =&#62; [&#39;cone&#39;, &#39;snail&#39;],
                              max_entries =&#62; 2,
                              &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
   while (my
      $record = $query-&#62;next) {
      print $record . &#34;\n&#34;;
   }

   interpro  ipr020242    29.7122746  Conotoxin I2-superfamily
   interpro  ipr012322    27.8191032  Conotoxin, delta-type, conserved site
   omim      114020       3.40963793  cadherin 2
   omim      192090       3.40769672  cadherin 1
   sprot     cxd6d_concn  19.4017849  Delta-conotoxin CnVID;
   sprot     cxd6c_concn  19.3984871  Delta-conotoxin CnVIC;
   taxonomy  6495         53.980381   Conus tulipa fish-hunting cone snail
   trembl    q71ks8_contu 22.1446457  Four-loop conotoxin preproprotein;
   trembl    q9u7q6_contu 20.6787205  Calmodulin;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="blast"
>blast</a></h3>

<pre>   $client-&#62;blast</pre>

<p>A factory method for creating a singleton instance of <em>MRS::Client::Blast</em>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="clustal"
>clustal</a></h3>

<pre>   $client-&#62;clustal</pre>

<p>A factory method for creating instances of <em>MRS::Client::Clustal</em>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Databank"
>MRS::Client::Databank</a></h2>

<p>This package represents an MRS databank and allows to query it. Each databank consists of one or more files (represented by <code>MRS::Client::Databank::File</code>) and of indices (<code>MRS::Client::Databank::Index</code>).</p>

<p>A databank instance can be created by a <i>new</i> method but usually it is created by a factory method available in the <code>MRS::Client</code>:</p>

<pre>   my $db = $client-&#62;db (&#39;enzyme&#39;);</pre>

<p>The factory method, as well as the <i>new</i> method, creates only a &#34;shell&#34; databank instance - that is good enough for making queries but which does not contain any databank properties (name, indices, etc.) yet. The properties will be fetched from the MRS server only when you ask for them (using the &#34;getter&#34; methods described below).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>The only, and mandatory, parameter is <i>id</i>:</p>

<pre>   $db = MRS::Client::Databank-&#62;new (id =&#62; &#39;interpro&#39;);</pre>

<p>The arguments syntax (the hash) is prepared for more arguments later (perhaps). But it should not bother you because you would rarely use this method - having the factory method <i>db</i> in the client.</p>

<p><i>Recommendation:</i> Do not use this method directly, or check first how it is used in the module <code>MRS::Client</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="find"
>find</a></h3>

<p>This is the crucial method of the whole <code>MRS::Client</code> module. It queries a databank and returns an <code>MRS::Client::Find</code> instance that can be used to iterate over found entries.</p>

<p>It takes many arguments. At least one of the &#34;query&#34; arguments (which are <i>query</i>, <i>and</i> and <i>or</i>) must be supplied; other arguments are optional.</p>

<p>The arguments can always be specified as a hash, but for usual cases there are few shortcuts. Let&#39;s look at the arguments as used in the hash:</p>

<dl>
<dt><a name="and"
><code>and</code></a></dt>

<dd>
<p>The value is an array reference where elements are terms that will be combined by the AND boolean operator in a ranked query. For example:</p>

<pre>   $find = $db-&#62;find (&#39;and&#39; =&#62; [&#39;human&#39;, &#39;snake&#39;]);</pre>

<p>This argument can also be used directly, not as a hash, assuming that you do not need to use any other arguments:</p>

<pre>   $find = $db-&#62;find ([&#39;human&#39;, &#39;snake&#39;]);</pre>

<dt><a name="or"
><code>or</code></a></dt>

<dd>
<p>The value is an array reference where elements are terms that will be combined by the OR boolean operator in a ranked query. For example:</p>

<pre>   $find = $db-&#62;find (&#39;or&#39; =&#62; [&#39;human&#39;, &#39;snake&#39;]);</pre>

<p>There can be either an <i>and</i> or an <i>or</i> argument, but not both. If there are used both, a warning is issued and the <i>and</i> one will take precedence.</p>

<dt><a name="query"
><code>query</code></a></dt>

<dd>
<p>The value is an expression, usually using some boolean operators (in upper cases!):</p>

<pre>   $find = $db-&#62;find (query =&#62; &#39;hemoglobinase AND NOT human&#39;);</pre>

<p>If there are no boolean operators, it is used as a single term. For example, these are equivalent:</p>

<pre>   $find = $db-&#62;find (query =&#62; &#39;hemoglobinase activity&#39;);
   $find = $db-&#62;find (&#39;and&#39; =&#62; [&#39;hemoglobinase activity&#39;]);</pre>

<p>You can also use both, <i>and</i> or <i>or</i>, and <i>query</i>. The query then is an additional filter applied to the results found by the <i>and</i> or <i>or</i> terms. For example:</p>

<pre>   $find = $db-&#62;find (&#39;and&#39; =&#62; [&#39;human&#39;, &#39;snake&#39;],
                      query =&#62; &#39;NOT neurotoxin&#39;);</pre>

<p>As a shortcut, the query parameter can also be used without a hash, assuming again that you do not need to use any other arguments:</p>

<pre>   $find = $db-&#62;find (&#39;hemoglobinase AND NOT human&#39;);</pre>

<dt><a name="algorithm"
><code>algorithm</code></a></dt>

<dd>
<p><b>Attention:</b> This argument is used only by MRS version 5, See <a href="#MRS_VERSIONS" class="podlinkpod"
>&#34;MRS VERSIONS&#34;</a> for details.</p>

<p>The ranked queries (the ones achieved by <i>and</i> or <i>or</i> arguments) have assigned relevance score to their hits. The relevance score depends on the used algorithm. The available values for this arguments are defined in <code>MRS::Algorithm</code>:</p>

<pre>   package MRS::Algorithm;
   use constant {
      VECTOR   =&#62; &#39;Vector&#39;,
      DICE     =&#62; &#39;Dice&#39;,
      JACCARD  =&#62; &#39;Jaccard&#39;,
   };</pre>

<p>The default algorithm is &#34;Vector&#34;. For example (using the format &#34;header&#34; - which is the only one that shows relevance scores):</p>

<pre>   $client-&#62;$db(&#39;enzyme&#39;)-&#62;find (&#39;and&#39; =&#62; &#39;venom&#39;,
                                 algorithm =&#62; MRS::Algorithm-&#62;Dice,
                                 max_entries =&#62; 3,
                                 &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
   enzyme  3.4.24.43    14.9607477      Atroxase.
   enzyme  3.4.24.49    13.6817474      Bothropasin.
   enzyme  3.4.24.73    13.2007284      Jararhagin.

   $client-&#62;$db(&#39;enzyme&#39;)-&#62;find (&#39;and&#39; =&#62; &#39;venom&#39;,
                                 algorithm =&#62; MRS::Algorithm-&#62;Vector,
                                 max_entries =&#62; 3,
                                 &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HEADER);
   enzyme  3.1.15.1     21.6520195      Venom exonuclease.
   enzyme  3.4.21.60    19.3931656      Scutelarin.
   enzyme  5.1.1.16     16.7410889      Protein-serine epimerase.</pre>

<dt><a name="start,_offset,_max_entries"
><code>start</code>, <code>offset</code>, <code>max_entries</code></a></dt>

<dd>
<p>These arguments do not affect the query itself but it tells which entries from the found ones to retrieve (by the <i>next</i> method - see below).</p>

<p>All these three arguments have an integer value.</p>

<p><code>start</code> tells to skip entries at the beginning of the whole result and start returning only with the entry with this order number. The counting start from 1.</p>

<p><code>offset</code> is the same as the <code>start</code>, except the counting starts from zero.</p>

<p><code>max_entries</code> is the maximum entries to retrieve.</p>

<dt><a name="format"
><code>format</code></a></dt>

<dd>
<p>This argument also does not affect the query itself but it defines the format of the returned entries. The available values for this arguments are defined in <code>MRS::EntryFormat</code>:</p>

<pre>   package MRS::EntryFormat;
   use constant {
       PLAIN    =&#62; &#39;plain&#39;,
       TITLE    =&#62; &#39;title&#39;,
       HTML     =&#62; &#39;html&#39;,
       FASTA    =&#62; &#39;fasta&#39;,
       SEQUENCE =&#62; &#39;sequence&#39;,
       HEADER   =&#62; &#39;header&#39;,
   };</pre>

<p>The default format is &#39;plain&#39;. The &#39;fasta&#39; and &#39;sequence&#39; formats are available only for databanks that have sequence data. For all formats, except for the &#39;header&#39;, the entries are returned as strings. For &#39;header&#39;, the entries are instances of <code>MRS::Client::Hit</code>.</p>

<p>Be aware that <code>format</code> is also a built-in Perl function, so better quote it when used as a hash key (it seems to work also without quotes except the emacs TAB key is confused if there are no surrounding quotes; just a minor annoyance).</p>

<dt><a name="xformat"
><code>xformat</code></a></dt>

<dd>
<p>This argument (<code>eXtended format</code>) enhances the <code>format</code> argument. It is used (at least at the moment) only for HTML format; for other formats, it is ignored. See, however, the <a href="#MRS_VERSIONS" class="podlinkpod"
>&#34;MRS VERSIONS&#34;</a> about the abandoned HTML format.</p>

<p>Be aware, however, that the <code>xformat</code> depends on the structure of the HTML provided by the MRS. This structure is not defined in the MRS server API, so it can change easily. It even depends on the way how the authors write their parsing scripts. When the HTML output changes this module must be changed, as well. Caveat emptor.</p>

<p>The <code>xformat</code> is a hashref with keys that change (slightly or significantly) the returned HTML. Here are all possible keys (with a randomly picked up values):</p>

<pre>   xformat =&#62; { MRS::XFormat::CSS_CLASS()   =&#62; &#39;mrslink&#39;,
                MRS::XFormat::URL_PREFIX()  =&#62; &#39;http://cbrcgit:8080/mrs-web/&#39;
                MRS::XFormat::REMOVE_DEAD() =&#62; 1, # &#39;or&#39; =&#62; [&#39;...&#39;]
                MRS::XFormat::ONLY_LINKS()  =&#62; 1 }</pre>

<p><code>MRS::XFormat::CSS_CLASS</code> specifies a CSS-class name that will be added to all <code>a</code> tags in the returned HTML. It allows, for example, an easy post-processing by various JavaScript libraries. For example, if the original HTML contains:</p>

<pre>   &#60;a href=&#34;entry.do?db=go&#38;amp;id=0005576&#34;&#62;&#60;/a&#62;</pre>

<p>it will become (using the value shown above):</p>

<pre>   &#60;a class=&#34;mrslinks&#34; href=&#34;entry.do?db=go&#38;amp;id=0005576&#34;&#62;&#60;/a&#62;</pre>

<p><code>MRS::XFormat::URL_PREFIX</code> helps to keep the returned HTML independent on the machine where it was created. This option pre-pends the given prefix to the relative URLs in the hyperlinks that point to the data in an MRS web application. For example, if the original HTML contains:</p>

<pre>   &#60;a href=&#34;entry.do?db=go&#38;amp;id=0005576&#34;&#62;&#60;/a&#62;</pre>

<p>it will become:</p>

<pre>   &#60;a href=&#34;http://cbrcgit:8080/mrs-web/entry.do?db=go&#38;amp;id=0005576&#34;&#62;&#60;/a&#62;</pre>

<p>Other hyperlinks - those not starting with <code>query</code> or <code>entry</code> - are not affected.</p>

<p><code>XFormat::REMOVE_DEAD</code> deals with the fact that the MRS server creates hyperlinks pointing to other MRS databanks without checking that they actually exists in the local MRS installation. This may be fixed later (quoting Maarten) but before it happens this option (if with a true value) removes (from the returned HTML) all hyperlinks that point to the not-installed MRS databanks. For example, if the original HTML has these hyperlinks:</p>

<pre>    &#60;a href=&#34;query.do?db=embl&#38;amp;query=ac:AF536179&#34;&#62;AF536179&#60;/a&#62;
    &#60;a href=&#34;query.do?db=embl&#38;amp;query=ac:D00735&#34;&#62;D00735&#60;/a&#62;
    &#60;a href=&#34;entry.do?db=pdb&#38;amp;id=1VZN&#34;&#62;1VZN&#60;/a&#62;
    &#60;a href=&#34;entry.do?db=pdb&#38;amp;id=2FK4&#34;&#62;2FK4&#60;/a&#62;</pre>

<p>and the <code>pdb</code> database is not locally installed, the returned HTML will change to:</p>

<pre>    &#60;a href=&#34;query.do?db=embl&#38;amp;query=ac:AF536179&#34;&#62;AF536179&#60;/a&#62;
    &#60;a href=&#34;query.do?db=embl&#38;amp;query=ac:D00735&#34;&#62;D00735&#60;/a&#62;
    1VZN
    2FK4</pre>

<p>There is a small caveat, however. The MRS::Client needs to know what databanks are installed. It finds out by asking the MRS server by using the method <code>db()</code> (explained elsewhere in this document). This method returns much more than is needed, so it can be slightly expensive. Therefore, if your concern is the highest speed, you can help the MRS::Client by providing a list of databanks that you know you have installed. Actually, in most cases, you can create such list also by calling the <code>db()</code> method but depending on your code you can call it just ones an reuse it. For example, if you wish to keep hyperlinks only for &#39;uniprot&#39; and &#39;embl&#39;, you specify;</p>

<pre>     xformat  =&#62; { MRS::XFormat::REMOVE_DEAD() =&#62; [&#39;uniprot&#39;, &#39;embl&#39;] }</pre>

<p>Finally, there is an option <code>MRS::XFormat::ONLY_LINKS</code>. It has a very specific function: to extract and return <code>only</code> the hyperlinks, not the whole HTML. It is, therefore, predestined for further post-processing. Note that all changes in the hyperlinks described earlier are also applied here (e.g. adding an absolute URL or a CSS class).</p>

<p>When this option is used, the whole method &#34;$find-&#62;next&#34; (or &#34;db-&#62;entry&#34;) returns a reference to an array of extracted hyperlinks:</p>

<pre>    my $find = $client-&#62;db(&#39;sprot&#39;)-&#62;find
        (and      =&#62; [&#39;DNP_DENAN&#39;],
         &#39;format&#39; =&#62; MRS::EntryFormat-&#62;HTML,
         xformat  =&#62; {
             MRS::XFormat::ONLY_LINKS()  =&#62; 1,
             MRS::XFormat::CSS_CLASS()   =&#62; &#39;mrslink&#39;,
         },
    );
    while (my $record = $find-&#62;next) {
    print join (&#34;\n&#34;, @$record) . &#34;\n&#34;;</pre>

<p>Which prints something like:</p>

<pre>    &#60;a class=&#34;mrslink&#34; href=&#34;entry.do?db=taxonomy&#38;amp;id=8618&#34;&#62;8618&#60;/a&#62;
    &#60;a class=&#34;mrslink&#34; href=&#34;query.do?db=taxonomy&#38;amp;query=Eukaryota&#34;&#62;Eukaryota&#60;/a&#62;
    ...
    &#60;a class=&#34;mrslink&#34; href=&#34;query.do?db=uniprot&#38;amp;query=kw:Disulfide kw:bond &#34;&#62;Disulfide bond&#60;/a&#62;
    ...
    &#60;a class=&#34;mrslink&#34; href=&#34;http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=...&#34;&#62;92332489&#60;/a&#62;
    ...
    &#60;a class=&#34;mrslink&#34; href=&#34;entry.do?db=go&#38;amp;id=0009405&#34;&#62;&#60;/a&#62;</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="count"
>count</a></h3>

<p>It returns a number of entries in the whole databank.</p>

<pre>   print $client-&#62;db (&#39;enzyme&#39;)-&#62;count;
   4645</pre>

<p>Do not confuse it with the method of the same name but called on the object returned by the <i>find</i> method - that one returns a number of hits of that particular query.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="entry"
>entry</a></h3>

<p>It takes an entry ID (mandatory), and optionally its format and extended format, and it returns the given entry:</p>

<pre>   print $client-&#62;db (&#39;enzyme&#39;)-&#62;entry (&#39;3.4.21.60&#39;);
   ID   3.4.21.60
   DE   Scutelarin.
   AN   Taipan activator.
   CA   Selective cleavage of Arg-|-Thr and Arg-|-Ile in prothrombin to form
   CA   thrombin and two inactive fragments.
   CC   -!- From the venom of Taipan snake (Oxyuranus scutellatus).
   CC   -!- Converts prothrombin to thrombin in the absence of coagulation factor
   CC       Va, and is potentiated by phospholipid and calcium.
   CC   -!- Specificity is similar to that of factor Xa.
   CC   -!- Binds calcium via gamma-carboxyglutamic acid residues.
   CC   -!- Similar enzymes are known from the venom of other Australian elapid
   CC       snakes Pseudonaja textilis, Oxyuranus microlepidotus and Demansia
   CC       nuchalis affinis.
   CC   -!- Formerly EC 3.4.99.28.
   //

    print $client-&#62;db (&#39;enzyme&#39;)-&#62;entry (&#39;3.4.21.60&#39;,
                                         MRS::EntryFormat-&#62;TITLE);
    Scutelarin.</pre>

<p>The optional <code>extended format</code> is a hashref and it was explained earlier in the section about the <code>find()</code> method.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="id,_name,_version,_blastable,_url,_script,_files,_indices,_aliases"
>id, name, version, blastable, url, script, files, indices, aliases</a></h3>

<p>There are several methods delivering databank properties. They have no arguments:</p>

<pre>   my $db = $client-&#62;db(&#39;omim&#39;);
   print $db-&#62;id        . &#34;\n&#34;;
   print $db-&#62;name      . &#34;\n&#34;;
   print $db-&#62;version   . &#34;\n&#34;;
   print $db-&#62;blastable . &#34;\n&#34;;
   print $db-&#62;url       . &#34;\n&#34;;
   print $db-&#62;script    . &#34;\n&#34;;
   print $db-&#62;aliases   . &#34;\n&#34;;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="files"
>files</a></h3>

<p>Each databank consists of one or more files. This method returns a reference to an array of <code>MRS::Client::Databank::File</code> instances. Each such instance has properties reachable by the following &#34;getters&#34; methods:</p>

<pre>   sub say { print @_, &#34;\n&#34;; }

   my $db_files = $client-&#62;db(&#39;uniprot&#39;)-&#62;files;
   foreach my $file (@{ $db_files }) {
      say $file-&#62;id;
      say $file-&#62;version;
      say $file-&#62;last_modified;
      say $file-&#62;entries_count;
      say $file-&#62;raw_data_size;
      say $file-&#62;file_size;
      say &#39;&#39;;
   }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="indices"
>indices</a></h3>

<p>Each databank is indexed by (usually several) indices. This method returns a reference to an array of <code>MRS::Client::Databank::Index</code> instances. Each such instance has properties reachable by the &#34;getters&#34; method:</p>

<pre>   my $db_indices = $client-&#62;db(&#39;uniprot&#39;)-&#62;indices;
   foreach my $idx (@{ $db_indices }) {
      printf (&#34;%-15s%-15s%9d  %-9s %s\n&#34;,
              $idx-&#62;db,
              $idx-&#62;id,
              $idx-&#62;count,
              $idx-&#62;type,
              $idx-&#62;description);
   }</pre>

<p>The index <i>id</i> is important because it can be used in the queries. For example, assuming that the database has an index <i>os</i> (organism species):</p>

<pre>   $db-&#62;find (query =&#62; &#39;rds AND os:human&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Find"
>MRS::Client::Find</a></h2>

<p>This object carries results of a query; it is returned by the <i>find</i> method, called either on a databank instance or on the whole client. Actually, in case of the whole client, the returned type is of type <code>MRS::Client::MultiFind</code> which is a subclass <code>MRS::Client::Find</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="db,_terms,_query,_all_terms_required,_max_entries"
>db, terms, query, all_terms_required, max_entries</a></h3>

<p>The getter methods just reflect query arguments (the ones given to the <code>find</code> method):</p>

<pre>   sub say { print @_, &#34;\n&#34;; }

   my $find = $client-&#62;db(&#39;uniprot&#39;)-&#62;find(&#39;sapiens&#39;);
   say $find-&#62;db;
   say join (&#34;, &#34;, @ {$find-&#62;terms });
   say $find-&#62;query;
   say $find-&#62;max_entries;
   say $find-&#62;all_terms_required;</pre>

<p>The <i>terms</i> (a ref array) are either from the <i>and</i> or <i>or</i> argument, and the <i>all_terms_required</i> is 1 (when terms are coming from the <i>and</i>) or zero.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="count"
>count</a></h3>

<p>Finally, you can get the number of hits of this query. Be aware (as mentioned elsewhere in this document) that boolean queries return only an estimate, usually much higher than is the reality.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::MultiFind"
>MRS::Client::MultiFind</a></h2>

<p>This object is returned from the <code>find</code> method made to all databanks. It is a subclass of the <code>MRS::Client::Find</code> with one additional method:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="db_counts"
>db_counts</a></h3>

<p>It returns databank names and their total counts in a hash (not a reference) where keys are the databank names and values the entry counts:</p>

<pre>    my %counts = $find-&#62;db_counts;
    foreach my $db (sort keys %counts) {
        printf (&#34;%-15s %9d\n&#34;, $db, $counts{$db});
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Hit"
>MRS::Client::Hit</a></h2>

<p>Finally, a tiny object representing a hit, a result of a query before going to a databank for the full contents of a found entry. It contains the databank&#39;s ID (where the hit was found), the score that this hit achieved (for boolean queries, the score is always 1) and the ID and title of the entry represented by this hit.</p>

<p>The corresponding getters methods are <i>db</i>, <i>score</i>, <i>id</i> and <i>title</i>.</p>

<p>The <i>next</i> method (as shown above) returns just hits (instead of the full entries) when the format <i>MRS::EntryFormat-</i>HEADER&#62; is specified.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Blast"
>MRS::Client::Blast</a></h2>

<p>The MRS servers provide sequence homology searches, the famous Blast program (namely the <i>blastp</i> program for protein sequences). An input sequence (in FASTA format) is searched against one of the MRS databanks. It can be any MRS databank whose method <code>blastable</code> returns true (e.g. uniprot). An input sequence and a databank are the only mandatory input parameters. Other common Blast parameters are also supported.</p>

<p>The invocation is asynchronous. It means that the <i>run</i> method returns immediately, without waiting for the Blast program to finish, giving back a <i>job id</i>, a handler that can be used later for polling for status, and, once status indicates the Blast finishes, for getting results (or an error message). This is the typical usage:</p>

<pre>    my @run_args = (fasta_file =&#62; &#39;...&#39;, db =&#62; &#39;...&#39;, ...);
    my $job = $client-&#62;blast-&#62;run (@run_args);
    sleep 10 while (not $job-&#62;completed);
    print $job-&#62;error if $job-&#62;failed;
    print $job-&#62;results;

    529.0   1.346582e-149  [vsph_trije  ]  1 Snake venom serine protease homolog;
    509.0   1.411994e-143  [vspa_triga  ]  1 Venom serine proteinase 2A;
    508.0   2.823987e-143  [vsp1m_trist ]  1 Venom serine protease 1 homolog;
    506.0   1.129595e-142  [vsp07_trist ]  1 Venom serine protease KN7 homolog;
    488.0   2.961165e-137  [vsp2_trifl  ]  1 Venom serine proteinase 2;
    487.0   5.922331e-137  [vsp1_trije  ]  1 Venom serine proteinase-like protein;
    456.0   1.271811e-127  [vsp04_trist ]  1 Venom serine protease KN4 homolog;
    ...</pre>

<p>You can also use provided script <code>mrsblast</code> that polls for you (if you wish so).</p>

<p>In order to create an <code>MRS::Client::Blast</code> instance, use the factory method:</p>

<pre>   my $blast = $client-&#62;blast;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="run"
>run</a></h3>

<p>The main method that starts Blast with the given parameters and immediately returns an object <code>MRS::Client::Blast::Job</code> that can be used for all other important methods. If you plan to stop your Perl program and start it again later, you need to remember the job ID:</p>

<pre>   my $job = $blast-&#62;run (...);
   print $job-&#62;id;</pre>

<p>The job ID can be later used to re-create the same (well, similar) Job object (see method <i>job</i> below) that again provides all important methods (such as getting results).</p>

<p>The method <i>run</i> has following arguments (the Job object has the same &#34;getter&#34; methods), all given as a hash:</p>

<dl>
<dt><a name="db"
>db</a></dt>

<dd>
<p>An MRS databank to search against. Mandatory parameter.</p>

<dt><a name="fasta"
>fasta</a></dt>

<dd>
<p>A protein sequence in a FASTA format. Mandatory parameter unless <code>fasta_file</code> is given.</p>

<dt><a name="fasta_file"
>fasta_file</a></dt>

<dd>
<p>A name of a file containing a protein sequence in a FASTA format. Mandatory parameter unless <code>fasta</code> is given.</p>

<dt><a name="filter"
>filter</a></dt>

<dd>
<p>Low complexity filter. Boolean parameter. Default is 1.</p>

<dt><a name="expect"
>expect</a></dt>

<dd>
<p>E-value cutoff. A float value. Default is 10.0.</p>

<dt><a name="word_size"
>word_size</a></dt>

<dd>
<p>An integer. Default is 3.</p>

<dt><a name="matrix"
>matrix</a></dt>

<dd>
<p>Scoring matrix. Default BLOSUM62.</p>

<dt><a name="open_cost"
>open_cost</a></dt>

<dd>
<p>Gap opening penalty. An integer. Default is 11.</p>

<dt><a name="extend_cost"
>extend_cost</a></dt>

<dd>
<p>Gap extension penalty. Default is 1.</p>

<dt><a name="query"
>query</a></dt>

<dd>
<p>An MRS boolean query to limit the search space.</p>

<dt><a name="gapped"
>gapped</a></dt>

<dd>
<p>A boolean parameter. Its true value performs gapped alignment. Default is true.</p>

<dt><a name="max_hits"
>max_hits</a></dt>

<dd>
<p>Limit reported hits. An integer. Default is 250.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="job"
>job</a></h3>

<p>The method finds or re-creates a Job object of the given ID:</p>

<pre>   my $job = $client-&#62;blast-&#62;job (&#39;0f37a544-a7a2-4239-b950-65a6aa07d1ef&#39;);
   print $job-&#62;id;
   print $job-&#62;status;</pre>

<p>It dies with an error if such Job is not known to the MRS server.</p>

<p>The returned Job object can be used to ask for the Job status, or for getting the Job results. There is one caveat, however. The re-created Job object is not that &#34;rich&#34; as was its original version: it does not know, for example, what parameters were used to start this blast job. Unfortunately, the MRS server keeps only the Job ID and nothing else. Fortunately, the parameters are needed only for the results in the XML format (see more about available formats below, in the method <i>$job-&#62;results</i>) - and you can add them (if you still have them), as a hash, to the <code>job</code> method when re-creating a new Job instance:</p>

<pre>   my $job - $client-&#62;blast-&#62;job (&#39;0f37a544-a7a2-4239-b950-65a6aa07d1ef&#39;,
                                  fasta =&#62; &#39;...&#39;,
                                  db    =&#62; &#39;iniprot&#39;, ...);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Blast::Job"
>MRS::Client::Blast::Job</a></h2>

<p>The Job object represents a single Blast invocation with a set of input parameters and, later, with results. It is also used to poll for the status of the running job. Instances of this objects are created by the <i>run</i> or <i>job</i> methods of the <code>blast</code> object. The Job&#39;s methods are:</p>

<dl>
<dt><a name="id"
>id</a></dt>

<dd>
<p>Job ID, an important handler if you have to re-create an <code>MRS::Client::Blast::Job</code> object.</p>

<dt><a name="&#34;getter&#34;_methods"
>&#34;getter&#34; methods</a></dt>

<dd>
<p>All these methods are equivalent to (and named the same as) the parameters given to the <code>run</code> method (described above):</p>

<dl>
<dt><a name="db"
>db</a></dt>

<dd>
<dt><a name="fasta"
>fasta</a></dt>

<dd>
<dt><a name="fasta_file"
>fasta_file</a></dt>

<dd>
<dt><a name="filter"
>filter</a></dt>

<dd>
<dt><a name="expect"
>expect</a></dt>

<dd>
<dt><a name="word_size"
>word_size</a></dt>

<dd>
<dt><a name="matrix"
>matrix</a></dt>

<dd>
<dt><a name="open_cost"
>open_cost</a></dt>

<dd>
<dt><a name="extend_cost"
>extend_cost</a></dt>

<dd>
<dt><a name="query"
>query</a></dt>

<dd>
<dt><a name="max_hits"
>max_hits</a></dt>

<dd>
<dt><a name="gapped"
>gapped</a></dt>

<dd>
<dt><a name="_"
></a></dt>
</dl>

<dt><a name="status,_completed,_failed"
>status, completed, failed</a></dt>

<dd>
<p>The <i>status</i> returns one of the <code>MRS::JobStatus</code>:</p>

<pre>   use constant {
      UNKNOWN  =&#62; &#39;unknown&#39;,
      QUEUED   =&#62; &#39;queued&#39;,
      RUNNING  =&#62; &#39;running&#39;,
      ERROR    =&#62; &#39;error&#39;,
      FINISHED =&#62; &#39;finished&#39;,
    };</pre>

<p>The <i>completed</i> returns true if the status is either <code>ERROR</code> or <code>FINISHED</code>. The <i>failed</i> returns true if the status is <code>ERROR</code>. Typical usage for polling a running job is:</p>

<pre>   sleep 10 while (not $job-&#62;completed);</pre>

<dt><a name="error"
>error</a></dt>

<dd>
<p>It returns an error message, or undef if the status is not <code>ERROR</code>. Typical usage is:</p>

<pre>   print $job-&#62;error if $job-&#62;failed;</pre>

<dt><a name="results"
>results</a></dt>

<dd>
<p>Finally, the more interesting method. It returns an object of type <code>MRS::Client::Blast::Result</code> that can be either used on its own (see its &#34;getter&#34; method below), or converted to strings of one of the format predefined in <code>MRS::BlastOutputFormat</code>:</p>

<pre>   use constant {
      XML   =&#62; &#39;xml&#39;,
      HITS  =&#62; &#39;hits&#39;,
      FULL  =&#62; &#39;full&#39;,
      STATS =&#62; &#39;stats&#39;,
   };</pre>

<p>The format is the only parameter of this method. Default format is <code>HITS</code>. The conversion to the given format is done by overloading the double quotes operator, calling internally the method &#34;as_string&#34;. You just print the object:</p>

<pre>   print $job-&#62;results;

   447.0   6.511672e-125  [vspgl_glosh ]  1 Thrombin-like enzyme gloshedobin;
   429.0   1.706996e-119  [vsp2_viple  ]  1 Venom serine proteinase-like protein 2;
   421.0   4.369909e-117  [vsp12_trist ]  1 Venom serine protease KN12;
   419.0   1.747964e-116  [vsps1_trist ]  1 Thrombin-like enzyme stejnefibrase-1;
   ...</pre>

<p>Where lines are individual hits and columns are: <i>bit_score</i>, <i>expect</i>, sequence ID, number of HSPs for this hit, sequence description.</p>

<p>Or, giving just the Blast run statistics:</p>

<pre>   print $job-&#62;results (MRS::BlastOutputFormat-&#62;STATS);

   DB count:     514212
   DB length:    180900945
   Search space: 23664675636
   Kappa:        0.041
   Lambda:       0.267
   Entropy:      0.140</pre>

<p>Or, showing everything (in a rather un-parsable form, useful more for testing than anything else):</p>

<pre>   print $job-&#62;results (MRS::BlastOutputFormat-&#62;FULL);</pre>

<p>Or, in an XML format:</p>

<pre>   print $job-&#62;results (MRS::BlastOutputFormat-&#62;XML);</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Blast::Result"
>MRS::Client::Blast::Result</a></h2>

<p>You can explore the returned Blast results by the following &#34;getter&#34; methods - going from the whole result to the individual hits and inside hits to the individual HSPs (High-scoring pairs):</p>

<dl>
<dt><a name="db_count"
>db_count</a></dt>

<dd>
<dt><a name="db_length"
>db_length</a></dt>

<dd>
<dt><a name="db_space"
>db_space</a></dt>

<dd>
<pre>   Effective search space.</pre>

<dt><a name="kappa"
>kappa</a></dt>

<dd>
<dt><a name="lambda"
>lambda</a></dt>

<dd>
<dt><a name="entropy"
>entropy</a></dt>

<dd>
<dt><a name="hits"
>hits</a></dt>

<dd>
<p>It returns a reference to an array of <code>MRS::Client::Blast::Hit</code>s where each hit has methods:</p>

<dl>
<dt><a name="id"
>id</a></dt>

<dd>
<dt><a name="title"
>title</a></dt>

<dd>
<dt><a name="sequences"
>sequences</a></dt>

<dd>
<p>It is a reference to an array of sequence IDs.</p>

<dt><a name="hsps"
>hsps</a></dt>

<dd>
<p>It is a reference to an array of <code>MRS::Client::Blast::HSP</code>s where each HSP has methods:</p>

<dl>
<dt><a name="score"
>score</a></dt>

<dd>
<dt><a name="bit_score"
>bit_score</a></dt>

<dd>
<dt><a name="expect"
>expect</a></dt>

<dd>
<dt><a name="query_start"
>query_start</a></dt>

<dd>
<dt><a name="subject_start"
>subject_start</a></dt>

<dd>
<dt><a name="identity"
>identity</a></dt>

<dd>
<dt><a name="positive"
>positive</a></dt>

<dd>
<dt><a name="gaps"
>gaps</a></dt>

<dd>
<dt><a name="subject_length"
>subject_length</a></dt>

<dd>
<dt><a name="query_align"
>query_align</a></dt>

<dd>
<dt><a name="subject_align"
>subject_align</a></dt>

<dd>
<dt><a name="midline"
>midline</a></dt>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>Try to explore various result formats by using the provided script <code>mrsblast</code>. This waits for a job to be completed and then prints its hits:</p>

<pre>   mrsblast -d sprot -i &#39;your.fasta&#39;</pre>

<p>This shows Blast statistics:</p>

<pre>   mrsblast -d sprot -i &#39;your.fasta&#39; -N</pre>

<p>This produces an XML output to a given file:</p>

<pre>   mrsblast -d sprot -i &#39;your.fasta&#39; -x results.xml</pre>

<p>Finally, this gives a long listing with all details:</p>

<pre>   mrsblast -d sprot -i &#39;your.fasta&#39; -f</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Clustal"
>MRS::Client::Clustal</a></h2>

<p><b>Attention:</b> This module is used only by MRS version 5, See <a href="#MRS_VERSIONS" class="podlinkpod"
>&#34;MRS VERSIONS&#34;</a> for details.</p>

<p>The module wrapping the multiple alignment program <i>clustalw</i>. The program is optional and, therefore, not all MRS servers may have it. Use the factory method for creating instances of <em>MRS::Client::Clustal</em>:</p>

<pre>   $client-&#62;clustal</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="run"
>run</a></h3>

<p>The main method, invoking <i>clustalw</i> with mandatory input sequences and optionally a couple of other parameters:</p>

<pre>   my $result = $client-&#62;clustal-&#62;run (fasta_file =&#62; &#39;my.proteins.fasta&#39;);</pre>

<dl>
<dt><a name="fasta_file"
>fasta_file</a></dt>

<dd>
<p>A file with multiple sequences in FASTA format.</p>

<dt><a name="open_cost"
>open_cost</a></dt>

<dd>
<p>A gap opening penalty (an integer).</p>

<dt><a name="extend_cost"
>extend_cost</a></dt>

<dd>
<p>A gap extension penalty (a float).</p>
</dd>
</dl>

<p>It returns result in an instance of <em>MRS::Client::Clustal::Result</em>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="open_cost"
>open_cost</a></h3>

<p>It returns what gap opening penalty has been set in the <i>run</i> method.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="extend_cost"
>extend_cost</a></h3>

<p>It returns what gap extension penalty has been set in the <i>run</i> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MRS::Client::Clustal::Result"
>MRS::Client::Clustal::Result</a></h2>

<p>It is created by running:</p>

<pre>   $client-&#62;clustal-&#62;run (...);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alignment"
>alignment</a></h3>

<p>It returns a reference to an array of <em>MRS::Client::Clustal::Sequence</em> instances. Each of them has methods <i>id</i> and <i>sequence</i>. You can also just print the formatted alignment (it uses its own <i>as_string</i> method that overloads double quotes operator):</p>

<pre>   print $client-&#62;clustal-&#62;run (fasta_file =&#62; &#39;several.proteins.fasta&#39;);

   vsph_trije : -VMGWGTISATKETHPDVPYCANINILDYSVCRAAYARLPATSRTLCAGILE-----GGKDSCLTD----SGGPLICNGQFQGIVSWGGHPCGQP-RKPGLYTKVFDHLDWIKSIIAGNKDATCPP
   nxsa_latse : ----MKTLLLTLVVVTIV--CLDLGYTR--ICFNHQSSQPQTTKT-CS---------PGESSCYNK----QWS------DFRGTIIERG--CGCPTVKPGI------KLSCCESEVCNN-------
   pa21b_pseau: NLIQFGNMIQCANKGSRP--SLDYADYG-CYCGWGGSGTPVDELDRCCQVHDNCYEQAGKKGCFPKLTLYSWKCTGNVPTCNSKPGCKSFVCACDAAAAKC----FAKAPYKKENYNIDTKKRCK-</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="diagnostics"
>diagnostics</a></h3>

<p>It shows the standard output of the underlying <em>clustalw</em> program:</p>

<pre>   my $result = $client-&#62;clustal-&#62;run (fasta_file =&#62; &#39;several.proteins.fasta&#39;);
   print $result-&#62;diagnostics;

    CLUSTAL 2.0.10 Multiple Sequence Alignments

   Sequence type explicitly set to Protein
   Sequence format is Pearson
   Sequence 1: vsph_trije    115 aa
   Sequence 2: nxsa_latse     83 aa
   Sequence 3: pa21b_pseau   118 aa
   Start of Pairwise alignments
   Aligning...

   Sequences (1:2) Aligned. Score:  13
   Sequences (1:3) Aligned. Score:  5
   Sequences (2:3) Aligned. Score:  8
   Guide tree file created: ...

   There are 2 groups
   Start of Multiple Alignment

   Aligning...
   Group 1:                     Delayed
   Group 2:                     Delayed
   Alignment Score -93

   GDE-Alignment file created ...</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="failed"
>failed</a></h3>

<p>It returns standard error output of the underlying <em>clustalw</em> program. It the program finished without problems, it returns undef.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MRS_VERSIONS"
>MRS VERSIONS</a></h1>

<p>The SOAP API of the MRS server slightly (or significantly, depending on what you were using) changed between version 5 and 6 (the version numbers indicate the MRS server version, not the version of the <code>MRS::Client</code> module). The <code>MRS::Client</code> module can work with both MRS server versions, but sometimes you have to tell what version you are planning to connect to.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new_parameter_mrs_version"
>new parameter <code>mrs_version</code></a></h3>

<p>By default, the <code>MRS::Client</code> assumes that it connects to an MRS server version 6 (or higher). But for MRS servers version 5 you need to add a new argument <b>mrs_version</b> to the client instance constructor with a value that differs from 6 (and it not zero or undef):</p>

<pre>   my $client = MRS::Client-&#62;new (mrs_version =&#62; 5, host =&#62; &#39;...&#39;);</pre>

<p>You can also set the expected version by an environment variable <code>MRS_VERSION</code>:</p>

<pre>   $ENV{MRS_VERSION} = 5;
   my $client = MRS::Client-&#62;new (host =&#62; &#39;...&#39;);</pre>

<p>You can also check what version your client is talking to, by a new method <b>is_v6</b> (mostly used rather internally):</p>

<pre>   $client-&#62;is_v6()   # returns 1 or 0</pre>

<p>The command-line tool <code>mrsclient</code> got an additional parameter <b>-V</b>:</p>

<pre>   mrsclient -V5 -H... -l</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="missing_some_result_formats"
>missing some result formats</a></h3>

<p>The MRS 6 server does not support anymore <b>HTML</b> and <b>sequence</b> result formats. The <code>sequence</code> format does not matter much because the <code>fasta</code> format continues to be provided and it is easy to get the pure sequence from it. But the lack of the <code>HTML</code> format is probably the most significant (downgrade) change.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="search_algorithm_not_supported"
>search algorithm not supported</a></h3>

<p>The MRS 6 server does not accept anymore requests for different search algorithms; it uses always the <b>Vector</b> algorithm.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="no_ClustalW_service"
>no ClustalW service</a></h3>

<p>The MRS 6 server does not provide multiple sequence alignment service. All remarks about ClustalW in this document are, therefore, valid only for the MRS 5.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="aliases"
>aliases</a></h3>

<p>The MRS 6 brings a new concept: <i>aliases</i>. An alias is a set of databases, usually closely related. A typical example is an alias <code>uniprot</code> that combines together two databases, the <code>sprot</code> (SwissProt) and <code>trembl</code> (TrEMBL). You can use an alias in all places where so far only database IDs were possible.</p>

<p>However, the list of databases returned by the &#34;db()&#34; method does not include the aliases. You need to ask individual databases for their aliases:</p>

<pre>   $client-&#62;db(&#39;sprot&#39;)-&#62;aliases();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MISSING_FEATURES,_CAVEATS,_BUGS"
>MISSING FEATURES, CAVEATS, BUGS</a></h1>

<ul>
<li>The MRS distinguishes between so-called <i>ranked queries</i> and <i>boolean queries</i>, and it recognizes also <i>boolean filters</i>. I probably need to learn more about their differences. That&#39;s why you may see some differences in query results shown by this module and the <b>mrsweb</b> web application (an application distributed together with the implementation of the MRS servers).
<p>The contents of the search field in the <i>mrsweb</i> is first parsed in order to find out if it is a boolean expression, or not. Depending on the result it uses either a ranked or boolean query. It also splits the terms and combine them (by default) with the logical AND. For example, in <i>mrsweb</i> if you type (using the <em>uniprot</em>):</p>

<pre>   cone snail</pre>

<p>you get 134 entries. You get the same number of hits by the <code>MRS::Client</code> module when using an <i>and</i> argument:</p>

<pre>   print $client-&#62;db(&#39;uniprot&#39;)-&#62;find (&#39;and&#39; =&#62; [&#39;cone&#39;,&#39;snail&#39;])-&#62;count;
   134</pre>

<p>But you cannot just pass the whole expression as a query string (as you do in <i>mrsweb</i>):</p>

<pre>   print $client-&#62;db(&#39;uniprot&#39;)-&#62;find (&#39;cone snail&#39;)-&#62;count;
   0</pre>

<p>You get zero entries because the <code>MRS::Client</code> considers the above as one term. And if you add a boolean operator:</p>

<pre>   print $client-&#62;db(&#39;uniprot&#39;)-&#62;find (&#39;cone AND snail&#39;)-&#62;count;
   4609</pre>

<p>then the boolean query was used and, as explained by the MRS, the &#34;query did not return an exact result, displaying the closest matches&#34;. But, fortunately, when you iterate over this result, you will get, correctly, just the 134 entries.</p>
</li>

<li>The MRS servers provide few more operations that are not-yet covered by this module. It would be useful to discuss which of those are worth to implement. They are:
<pre>   GetMetaData
   FindSimilar
   GetLinked
   Cooccurrence
   SpellCheck
   SuggestSearchTerms
   CompareDocuments
   ClusterDocuments</pre>

<p>There is also a potentially useful attribute <i>links</i> in the databank&#39;s info which has not been yet explored by this module.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ADDITIONAL_FILES"
>ADDITIONAL FILES</a></h1>

<p>Almost all functionality of the <code>MRS::Client</code> module is also available from a command-line controlled scripts <em>mrsclient</em>, <em>mrsblast</em> and <em>mrsclustal</em>. Try , for example:</p>

<pre>    mrsclient -h
    mrsclient -C
    mrsclient -c -n insulin
    mrsclient -c -p -d enzyme -a &#39;endothelin tyrosine&#39;
    mrsblast -h
    mrsclustal -h</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEPENDENCIES"
>DEPENDENCIES</a></h1>

<p>The <code>MRS::Client</code> module uses the following modules:</p>

<pre>   XML::Compile::SOAP11
   XML::Compile::WSDL11
   XML::Compile::Transport::SOAPHTTP
   File::Basename
   File::Path
   Math::BigInt
   FindBin
   Getopt::Std</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please report any bugs or feature requests to <a href="http://github.com/msenger/MRS-Client/issues" class="podlinkurl"
>http://github.com/msenger/MRS-Client/issues</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGMENTS"
>ACKNOWLEDGMENTS</a></h1>

<p>This client module would be useless without having an MRS server (e.g. at <em>http://mrs.cmbi.ru.nl/m6/</em>). The MRS stands for <b>Maarten&#39;s Retrieval System</b> and was developed (and is maintained) by <i>Maarten Hekkelman</i> at the CMBI (<em>http://www.cmbi.ru.nl/</em>), with the help and contributions from many others.</p>

<p>The MRS itself has also its own Perl module <em>MRS.pm</em>, called plugin and distributed together with the MRS, that accesses MRS server(s) directly, without using the SOAP Web Services protocol. The plugin was helpful to find out what the server might expect.</p>

<p>Additionally, the MRS distribution has few testing scripts that use SOAP protocol to access data in the same way as this <code>MRS::Client</code> module does. Therefore, this module can be seen as an extension of these testing scripts into a slightly more comprehensive and perhaps more documented package.</p>

<p>The MRS server provides Blast results that are not in XML. In order to make an XML output, this module uses, hopefully, the same format and conversion as found in the MRS web application.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Martin Senger &#60;martin.senger@gmail.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Martin Senger, CBRC - KAUST (Computational Biology Research Center - King Abdullah University of Science and Technology) All Rights Reserved..</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>

<!-- end doc -->

</body></html>
